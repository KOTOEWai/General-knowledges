
## 📑 Table of Contents

- [Vite](#Vite)
- [Bundler](#Bundler)
- [Call Stack နှင့် Memory Heap အလုပ်လုပ်ပုံ](#Call-Stack-နှင့်-Memory-Heap-အလုပ်လုပ်ပုံ)
- [Abstract Syntax Tree (AST)](#Abstract-Syntax-Tree-(AST))


## Vite

```
Vite (ပြင်သစ်ဘာသာစကားဖြင့် "အမြန်" ဟု အဓိပ္ပာယ်ရပြီး "veet" ဟု အသံထွက်သည်) သည်
 ခေတ်သစ် Web Development လောကတွင် အသုံးပြုနေကြသည့်
အလွန်မြန်ဆန်သော Build Tool တစ်ခု ဖြစ်ပါသည်။

အရင်က React project တွေမှာ အသုံးများခဲ့တဲ့ Create React App (CRA) နဲ့ Webpack 
တို့နေရာမှာ အခုဆိုရင် Vite က အစားထိုးဝင်ရောက်လာပြီ ဖြစ်ပါတယ်။

Vite က ဘာကြောင့် ပိုကောင်းတာလဲ?

Vite ကို အဓိက အချက် (၂) ချက်ကြောင့် လူကြိုက်များကြပါတယ်-

1. အလွန်မြန်သော Development Server: သင် code တစ်ခုခုပြင်လိုက်တိုင်း Browser မှာ
 ချက်ချင်းပြောင်းလဲသွားအောင် လုပ်ဆောင်ပေးတဲ့နေရာမှာ
 Webpack ထက် အဆပေါင်းများစွာ ပိုမြန်ပါတယ်။ ဒါကို Hot Module Replacement (HMR) လို့ ခေါ်ပါတယ်။

2. မြန်ဆန်သော Build Time: Project ကို အချောသတ် (Production) ထုတ်တဲ့အခါမှာလည်း
 ခေတ်မီတဲ့ Rollup bundler ကို အသုံးပြုထားလို့ 
file size သေးသေးနဲ့ မြန်မြန်ဆန်ဆန် ထွက်လာစေပါတယ်။

Vite ရဲ့ အဓိက ထူးခြားချက်များ

Instant Server Start: Project ကို စတင် run တဲ့အခါ စက္ကန့်ပိုင်းအတွင်း တက်လာပါတယ်။

TypeScript Ready: TypeScript အတွက် ဘာမှထပ်ပြင်စရာမလိုဘဲ အသင့်အသုံးပြုနိုင်ပါတယ်။

Optimized Build: သင့်ရဲ့ Website ကို အမြန်ဆုံး load ဖြစ်အောင် code တွေကို အလိုအလျောက် 
ကျစ်လျစ်အောင် လုပ်ပေးပါတယ်။

Plugin Ecosystem: လိုအပ်တဲ့ features တွေကို plugin တွေအဖြစ် အလွယ်တကူ ထည့်သွင်းနိုင်ပါတယ်။

မှတ်ချက်: အခုနောက်ပိုင်း React ရော၊ Vue ရော၊ အခြား Frontend Framework တွေမှာပါ Vite ကိုပဲ
 Standard အနေနဲ့ သုံးဖို့ အကြံပြုထားကြပါတယ်။
```


## Bundler
```
Bundler ဆိုတာ သင့်ရဲ့ Web Project မှာရှိတဲ့ ရာနဲ့ချီတဲ့ JavaScript file တွေ၊ CSS တွေနဲ့
ပုံ (Images) တွေကို
စုစည်းပြီး Browser က ဖတ်လို့ရမယ့် File အနည်းငယ် (ဥပမာ- bundle.js) ဖြစ်အောင် ပေါင်းစည်းပေးတဲ့ 
ကိရိယာ (Tool) တစ်ခုဖြစ်ပါတယ်။

* လွယ်လွယ်ပြောရရင်တော့ ဟင်းချက်တဲ့အခါ လိုအပ်တဲ့ ပါဝင်ပစ္စည်းတွေကို အိတ်တစ်အိတ်ထဲ စနစ်တကျ 
ထည့်ပေးလိုက်သလိုပါပဲ။

Bundler က ဘာကြောင့် လိုအပ်တာလဲ?

 ၁။ File တွေ အရမ်းများခြင်း: Developer တွေက အလုပ်လုပ်ရလွယ်အောင် code တွေကို
  file သေးသေးလေးတွေ အများကြီး ခွဲရေးကြပါတယ်။
  ဒါပေမဲ့ Browser က အဲဒီ file ပေါင်းများစွာကို တစ်ခုချင်းစီ လှမ်းခေါ်နေရင် Website က
  အရမ်းနှေးသွားပါလိမ့်မယ်။

 ၂။ Dependency Management: File တစ်ခုနဲ့တစ်ခု ချိတ်ဆက်နေမှု (ဥပမာ- A က B ကို အားကိုးနေတာမျိုး)
  ကို Bundler က စနစ်တကျ စီစဉ်ပေးပါတယ်။
 
 ၃။ Asset Optimization: Code တွေကို ကျစ်လျစ်အောင်လုပ်တာ (Minification) နဲ့ မလိုအပ်တဲ့ 
 code တွေကို ဖယ်ထုတ်တာ (Tree Shaking) တွေကို လုပ်ဆောင်ပေးပါတယ်။

Bundler တစ်ခု ဘယ်လိုအလုပ်လုပ်သလဲ?

Bundler က သင့်ရဲ့ Project ထဲက အဓိက file (Entry Point) ကို အရင်ကြည့်ပါတယ်။ 
အဲဒီကမှတစ်ဆင့် ချိတ်ဆက်နေတဲ့ အခြား file တွေကို လိုက်ရှာပြီး "Graph" တစ်ခု ဆောက်ပါတယ်။ 
နောက်ဆုံးမှာတော့ Browser နားလည်တဲ့ static file တွေအဖြစ် ပြောင်းလဲပေးလိုက်ပါတယ်။

သင်က Vite ကို သုံးနေတယ်ဆိုရင် Bundler အကြောင်းကို ခေါင်းထဲအများကြီး ထည့်စရာမလိုဘဲ
 သူက အနောက်ကနေ အကုန်လုံးကို အလိုအလျောက် အကောင်းဆုံးဖြစ်အောင် စီစဉ်ပေးသွားမှာပါ။
```
## Call Stack နှင့် Memory Heap အလုပ်လုပ်ပုံ

```
Reference types (Objects, Arrays) တွေအတွက် JavaScript က အခုလို ခွဲဝေလိုက်ပါတယ်-

Memory Heap
    တကယ့် Data အကြီးစားတွေ (ဥပမာ- { name: "Aung Aung", age: 25 }) ကို
ဒီနေရာမှာ သိမ်းပါတယ်။ ဒီနေရာက ကျယ်ဝန်းပြီး ရှုပ်ထွေးတဲ့ structure တွေကို သိမ်းဖို့ပါ။

Call Stack
    ဒီနေရာမှာတော့ variable နာမည်နဲ့ အဲဒီ data ရှိရာနေရာကို ညွှန်ပြတဲ့ 
Memory Address (Reference) ကိုပဲ သိမ်းပါတယ်။


ဘယ်လို အလုပ်လုပ်သလဲ (Step-by-Step)

ဥပမာ- let user = { name: "Aung Aung" }; လို့ ရေးလိုက်ရင်:

အဆင့် (၁): JavaScript က Heap ထဲမှာ နေရာလွတ်တစ်ခုရှာပြီး 
{ name: "Aung Aung" } ဆိုတဲ့ object ကို သိမ်းလိုက်ပါတယ်။ အဲဒီနေရာရဲ့ လိပ်စာက ဥပမာ 0x123 ဆိုပါစို့။

အဆင့် (၂): Call Stack ထဲမှာ user ဆိုတဲ့ variable name ကို သတ်မှတ်ပါတယ်။

အဆင့် (၃): Stack ထဲက user ရဲ့ value နေရာမှာ အစောက လိပ်စာ 0x123 ကို သိမ်းလိုက်ပါတယ်။

မှတ်ချက်: Stack ထဲမှာ object ကြီးတစ်ခုလုံး သိမ်းဖို့က နေရာမလောက်နိုင်သလို၊ ရှုပ်ထွေးနိုင်တာကြောင့် 
လိပ်စာကတ်လေး (Reference) ကိုပဲ Stack ထဲ ထည့်ထားတာ ဖြစ်ပါတယ်။


Location,        Identifier (Variable)            Value (Content)

Call Stack,          user,                           Ref: 0x123 (Address)
Memory Heap          0x123,                         { name: ""Aung Aung"" }


ဒါကြောင့် ဘာဖြစ်သလဲ?

သင်က let admin = user; လို့ ထပ်ရေးလိုက်ရင် JavaScript က Stack ထဲမှာ variable အသစ်တစ်ခု ဆောက်ပါတယ်။ 
ဒါပေမဲ့ သူက value အသစ်ကို copy ကူးတာ မဟုတ်ဘဲ 0x123 ဆိုတဲ့ လိပ်စာကိုပဲ copy ကူးလိုက်တာပါ။

ရလဒ်ကတော့ user ရော admin ရောက Heap ထဲက object တစ်ခုတည်းကိုပဲ ပိုင်ဆိုင်သွားတာ ဖြစ်ပါတယ်။

------------------------------------------------------------------------------------------------------------------

Primitive types (Number, String, Boolean, Null, Undefined, Symbol, BigInt)
တွေကတော့ Reference types တွေနဲ့ လုံးဝဆန့်ကျင်ဘက် အလုပ်လုပ်ပါတယ်။ သူတို့က memory ထဲမှာ
ပိုပြီးရိုးရှင်းသလို၊ ပိုလည်းမြန်ဆန်ပါတယ်။

Primitive types တွေ အလုပ်လုပ်ပုံကို အချက် (၃) ချက်နဲ့ ရှင်းပြပေးပါမယ်။

၁။ Call Stack ထဲမှာ တိုက်ရိုက်သိမ်းဆည်းခြင်း
Non-primitive တွေက Heap ထဲမှာ data သိမ်းပြီး Stack ထဲမှာ address ပဲသိမ်းပေမဲ့၊ 
Primitive types တွေကတော့ တကယ့် value (တန်ဖိုး) ကို 
Call Stack ထဲမှာပဲ တိုက်ရိုက် (Directly) သိမ်းပါတယ်။

ဥပမာ- let x = 10; လို့ ရေးလိုက်ရင် Stack ထဲက x ဆိုတဲ့ နေရာလေးမှာ 10 ဆိုတဲ့ တန်ဖိုးက 
တခါတည်း ရှိနေမှာပါ။ Heap ဆီ လှမ်းသွားနေဖို့ မလိုပါဘူး။

၂။ Pass by Value (တန်ဖိုးကိုသာ ကူးယူခြင်း)
ဒါက အရေးကြီးဆုံးအချက်ပါ။ Primitive variable တစ်ခုကို နောက်တစ်ခုထဲ ကူးထည့်လိုက်ရင် 
သူက လိပ်စာကို မပေးဘဲ တန်ဖိုးအစစ်ကို copy ပွား ပေးလိုက်တာပါ။

ဥပမာ-
JavaScript
let a = 50;
let b = a; // 'a' ထဲက 50 ကို copy ကူးပြီး 'b' ထဲ ထည့်လိုက်တာ

b = 100; // 'b' ကို ပြင်လိုက်ပေမဲ့

console.log(a); // 'a' က 50 ပဲ ရှိနေဆဲပါ။
ဘာကြောင့်လဲ: Stack ထဲမှာ a အတွက် နေရာတစ်ခု၊ b အတွက် နေရာတစ်ခု သီးသန့်စီ ဖြစ်သွားလို့ပါ။
 တစ်ခုကို ပြင်ရင် နောက်တစ်ခုကို လုံးဝ မထိခိုက်ပါဘူး။

၃။ Immutability (ပြောင်းလဲ၍မရခြင်း)
Primitive types တွေက Immutable ဖြစ်ပါတယ်။ ဆိုလိုတာက memory ထဲမှာရှိပြီးသား
 value တစ်ခုကို သွားပြင်လို့ မရပါဘူး။

ဥပမာ- let name = "Aung"; ဆိုပြီး သတ်မှတ်ပြီးမှ name = "Kyaw"; လို့ ပြောင်းလိုက်ရင်:

JavaScript က "Aung" ဆိုတဲ့ စာသားကို "Kyaw" ဖြစ်အောင် သွားပြင်တာ မဟုတ်ပါဘူး။

Memory (Stack) ထဲမှာ "Kyaw" ဆိုတဲ့ တန်ဖိုးအသစ်တစ်ခုကို ထပ်ဆောက်ပြီး name variable ကို
 အဲဒီတန်ဖိုးအသစ်ဆီ ပြောင်းခိုင်းလိုက်တာပါ။

အဟောင်း "Aung" ကတော့ ဘယ်သူမှ မသုံးတော့ရင် memory ထဲက ဖျက်ထုတ်ခြင်း ခံရမှာပါ။

```




## Abstract Syntax Tree (AST)
```
Abstract Syntax Tree (AST) ဆိုတာ ရိုးရိုးရှင်းရှင်း ပြောရရင် ကျနော်တို့ ရေးလိုက်တဲ့ 
Programming Code တွေကို Computer Engine (ဥပမာ- JS Engine) က နားလည်အောင်
အဆင့်ဆင့် ခွဲခြမ်းစိတ်ဖြာပြီး တည်ဆောက်လိုက်တဲ့ "သစ်ပင်ပုံစံ Structure" တစ်ခုဖြစ်ပါတယ်။

Code တွေကို စာသား (Text) အနေနဲ့ မဟုတ်ဘဲ Logical ဖြစ်တဲ့ အစိတ်အပိုင်းတွေအဖြစ် ခွဲထုတ်လိုက်တာပါ။

AST အလုပ်လုပ်ပုံ အဆင့်ဆင့်
JS Engine က Code တွေကို တိုက်ရိုက်မပတ်ဘဲ အောက်ပါအတိုင်း အဆင့်ဆင့် ပြောင်းလဲပါတယ်-

Lexical Analysis (Tokenization): ပထမဆုံး Code တွေကို const, x, =, 10 ဆိုပြီး 
အစိတ်အပိုင်း (Tokens) လေးတွေအဖြစ် အရင်ခွဲပါတယ်။

Syntax Analysis (Parsing): အဲဒီ Tokens လေးတွေကို စုစည်းပြီး တစ်ခုနဲ့တစ်ခု 
ဘယ်လိုဆက်စပ်လဲဆိုတာကို Tree ပုံစံ (AST) တည်ဆောက်ပါတယ်။

ဥပမာပြရရင်:
ကျနော်တို့က $const x = 5 + 3;$ လို့ ရေးလိုက်ရင် AST က ဒီလိုပုံစံမျိုး ဖြစ်သွားပါမယ်-

VariableDeclaration: const

Identifier: x

Expression: (Binary Expression)

Left: 5

Operator: +

Right: 3

AST ကို ဘာကြောင့် သုံးတာလဲ?
Engine တွေအတွက်တင်မကဘဲ ကျနော်တို့ နေ့စဉ်သုံးနေတဲ့ Tool တွေမှာလည်း AST က အရေးကြီးပါတယ်-

Minification: Code တွေထဲက မလိုအပ်တဲ့ space တွေ ဖယ်ထုတ်တာနဲ့ variable 
နာမည်တွေကို အတိုချုံ့တာ (ဥပမာ- longVariableName ကို a လို့ပြောင်းတာ) တွေမှာ သုံးပါတယ်။

Transpilation (Babel): Modern JS (ES6+) code တွေကို Browser အဟောင်းတွေမှာ
 အလုပ်လုပ်အောင် code ပြန်ပြောင်းတဲ့နေရာမှာ သုံးပါတယ်။

Linting (ESLint): ကျနော်တို့ code ရေးတာ မှားနေသလား၊ format မကျဘူးလားဆိုတာကို 
AST ကို ကြည့်ပြီး စစ်ဆေးပေးတာပါ။

အကျဉ်းချုပ်: AST ဆိုတာ Code ရဲ့ "Structure" ကို ဖော်ပြတဲ့ မြေပုံတစ်ခုဖြစ်ပြီး Engine က
 Code ကို မြန်မြန်ဆန်ဆန်နဲ့ တိတိကျကျ အကောင်အထည်ဖော်နိုင်အောင် ကူညီပေးပါတယ်။
```